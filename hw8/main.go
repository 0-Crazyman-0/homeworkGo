package main

import (
	"fmt"
	"math"
)

func main() {
	a := []int{1, 6, 8, 4, 9, 5, 3, 2, 1, 11, 9, 6}
	ma := fa(a)
	fmt.Printf("Максимальный элемент в массиве: %d\n", ma)

	b := []int{3, 5, 7, 2, 8, 10, 1, 4, 6, 9}
	mi := fi(b)
	fmt.Printf("Минимальный элемент в массиве: %d\n", mi)

	c := []int{-3, 5, 7, -2, 8, -10, 1, 4, -6, 9}
	t := cp(c)
	fmt.Printf("Количество положительных чисел в массиве: %d\n", t)

	// 4.	Найти сумму всех элементов массива.
	d := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21}
	f := 0
	for e := range d {
		f += e
	}
	fmt.Printf("Сумма всех элементов в массиве: %d\n", f)

	// 5.	Найти среднее значение всех элементов массива.
	g := []int{3, 4, 5, 6, 9, 7, 1, 2, 8, 9, 6, 5}
	gg := 0
	for ggg := range g {
		gg += ggg
	}
	fmt.Printf("Среднее значение всех элементов в массиве: %.2f\n", float64(gg)/float64(len(g)))

	// 7.	Умножить все элементы массива на заданное число
	h := [10]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
	hh := 2
	for hhh := range h {
		h[hhh] *= hh
	}
	fmt.Println("Умножение  всех элементов массива на заданное число равно ", h)

	// 8.	Найти все индексы заданного числа в массиве.
	l := []int{3, 5, 7, 2, 8, 2, 10, 1, 4, 2, 6, 9}
	ll := 2
	lll := []int{}
	for i, llll := range l {
		if llll == ll {
			lll = append(lll, i)
		}
	}
	fmt.Printf("Индексы числа %d в массиве: %v\n", ll, lll)

	// 9.	Создать копию массива.
	m := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	mm := make([]int, len(m))
	mmm := copy(mm, m)
	fmt.Println(mm)
	fmt.Println(mmm)

	// 10.	Объединить два массива.
	n := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	nn := []int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
	nnn := append(n, nn...)
	fmt.Printf("Объединенный массив: %v\n", nnn)
	// 11.	.Поменять местами максимальный и минимальный элементы массива
	ai := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	i, ii := 0, 0
	for iii, iiii := range ai {
		if iiii < ai[i] {
			i = iii
		}
		if iiii > ai[ii] {
			ii = iii
		}
	}
	ai[i], ai[ii] = ai[ii], ai[i]
	fmt.Printf("Массив после обмена : %v\n", ai)

	// 12..Проверить, является ли массив палиндромом
	aa := []int{1, 2, 3, 4, 5, 6}
	q := true
	qq := len(aa)
	for qqq := 0; qqq < qq/2; qq++ {
		if aa[qqq] != aa[qq-1-qqq] {
			q = false
			break
		}
	}
	if q {
		fmt.Println("Массив является палиндромом")
	} else {
		fmt.Println("Массив не является палиндромом")
	}

	// 6.	Удалить все вхождения заданного числа из массива.
	aaa := []int{}
	for dd := range a {
		if dd != ll {
			aaa = append(aaa, dd)
		}
	}
	fmt.Printf("Массив после удаления всех вхождений числа %d: %v\n", ll, aaa)

	//13
	xx := []int{3, 2, 1, 5, 6, 4, 8, 7}
	xxx := fsl(xx)
	fmt.Printf("Второе наибольшее число в массиве: %d\n", xxx)
	//14
	perev(xx)
	fmt.Printf("Перевернутый массив: %v\n", xx)
	//15
	z := []int{1, 2, 3, 2, 4, 5, 3, 6, 7, 5, 8, 9, 6, 10}
	zz := dublic(z)
	fmt.Printf("Массив без дубликатов: %v\n", zz)
	//16
	zzz := []int{0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6}
	nulli(zzz)
	fmt.Print("Массив после перемещения всех нулей в конец: %v\n", zzz)
}

// 1.	Найти максимальный элемент в массиве.
func fa(a []int) int {
	m := a[0]
	for _, b := range a {
		if b > m {
			m = b
		}
	}
	return m
}

// 2.	Найти минимальный элемент в массиве.
func fi(b []int) int {
	m := b[0]
	for _, a := range b {
		if a < m {
			m = a
		}
	}
	return m
}

// 3.	Подсчитать количество положительных чисел в массиве.
func cp(a []int) int {
	b := 0
	for _, c := range a {
		if c > 0 {
			b++
		}
	}
	return b
}

// 13.	Найти второе наибольшее число в массиве.
func fsl(a []int) int {
	m1, m2 := math.MinInt, math.MinInt
	for c := range a {
		if c > m1 {
			m2 = m1
			m1 = c
		} else if c > m2 && c != m1 {
			m2 = c
		}
	}
	if m2 == math.MinInt {
		return 0
	}
	return m2
}

// 14.	Перевернуть массив.
func perev(a []int) {
	b := len(a)
	for i := 0; i < b/2; i++ {
		a[i], a[b-1-i] = a[b-1-i], a[i]
	}
}

// 15.	Удалить дубликаты из массива.
func dublic(a []int) []int {
	b := make(map[int]bool)
	c := []int{}
	for d := range a {
		if !b[d] {
			b[d] = true
			c = append(c, d)
		}
	}
	return c
}

// 16.	Переместить все нули в конце массива, сохраняя порядок ненулевых элементов.
func nulli(a []int) {
	b := len(a)
	c := 0
	for i := 0; i < b; i++ {
		if a[i] != 0 {
			a[c] = a[i]
			c++
		}
	}
	for i := c; i < b; i++ {
		a[i] = 0
	}
}

// 17.	Найти пересечение двух массивов.
func peres(a, b []int) {
	c := len(a)
	d := len(b)
	e := []int{}

}

// 18.	Проверить, является ли массив подмножеством другого массива.

// 19.	Объединить два отсортированных массива в один отсортированный.

// 20.	Найти длину самого длинного подмассива, в котором все элементы различны.

// 21.	Найти все подмассивы, сумма которых равна заданному числу.

// 22.	Найти пару элементов в массиве, сумма которых равна заданному числу.

// 23.	Найти наименьший положительный элемент, отсутствующий в массиве.

// 24.	Найти максимальную сумму подмассива с условием, что подмассив не должен содержать более двух различных элементов.

// 25.	Найти максимальную длину подмассива, сумма элементов которого равна заданному числу.

// 26.	Найти максимальное произведение трех чисел в массиве.

// 27.	Найти подмассив с максимальной суммой.

// 28.	Переместить все отрицательные числа в начало массива, сохраняя порядок остальных чисел.

// 29.	Найти подмассив с наибольшей длиной, сумма элементов которого равна нулю.

// 30.	Найти наибольший общий д
